import type { TierAResult, CaptionTrack } from '@/types';
import {
  extractPlayerResponse,
  extractCaptionTracks,
  fetchTranscript,
} from '@/utils/youtube-api';

/**
 * Tier A: Extract transcript from YouTube's native caption system
 *
 * Sources checked in order:
 * 1. ytInitialPlayerResponse.captions.playerCaptionsTracklistRenderer
 * 2. Direct timedtext API fetch
 *
 * Prefers human captions over auto-generated
 */
export async function getTierATranscript(
  videoId: string,
  preferredLanguage = 'en'
): Promise<TierAResult | null> {
  try {
    // Extract player response from page
    const playerResponse = extractPlayerResponse();
    if (!playerResponse) {
      console.log('[ClearTranscript] No player response found');
      return null;
    }

    // Get available caption tracks
    const tracks = extractCaptionTracks(playerResponse);
    if (tracks.length === 0) {
      console.log('[ClearTranscript] No caption tracks available');
      return null;
    }

    // Select best track (prefer human, then preferred language)
    const selectedTrack = selectBestTrack(tracks, preferredLanguage);
    if (!selectedTrack) {
      console.log('[ClearTranscript] No suitable track found');
      return null;
    }

    // Fetch transcript from selected track
    const transcript = await fetchTranscript(selectedTrack.baseUrl);
    if (transcript.length === 0) {
      console.log('[ClearTranscript] Empty transcript returned');
      return null;
    }

    return {
      tier: 'A',
      source: selectedTrack.isAutoGenerated
        ? 'youtube-auto-generated'
        : 'youtube-captions',
      transcript,
      language: selectedTrack.languageCode,
      languageName: selectedTrack.languageName,
      availableTracks: tracks,
    };
  } catch (error) {
    console.error('[ClearTranscript] Tier A failed:', error);
    return null;
  }
}

/**
 * Fetch transcript for a specific language
 */
export async function getTierATranscriptForLanguage(
  videoId: string,
  languageCode: string
): Promise<TierAResult | null> {
  try {
    const playerResponse = extractPlayerResponse();
    if (!playerResponse) {
      return null;
    }

    const tracks = extractCaptionTracks(playerResponse);
    const track = tracks.find((t) => t.languageCode === languageCode);

    if (!track) {
      return null;
    }

    const transcript = await fetchTranscript(track.baseUrl);
    if (transcript.length === 0) {
      return null;
    }

    return {
      tier: 'A',
      source: track.isAutoGenerated
        ? 'youtube-auto-generated'
        : 'youtube-captions',
      transcript,
      language: track.languageCode,
      languageName: track.languageName,
      availableTracks: tracks,
    };
  } catch (error) {
    console.error('[ClearTranscript] Language switch failed:', error);
    return null;
  }
}

/**
 * Select the best caption track based on preferences
 *
 * Priority:
 * 1. Human captions in preferred language
 * 2. Human captions in any language
 * 3. Auto-generated in preferred language
 * 4. Auto-generated in any language
 */
function selectBestTrack(
  tracks: CaptionTrack[],
  preferredLanguage: string
): CaptionTrack | null {
  // Split tracks into human and auto-generated
  const humanTracks = tracks.filter((t) => !t.isAutoGenerated);
  const autoTracks = tracks.filter((t) => t.isAutoGenerated);

  // Try to find human caption in preferred language
  const humanPreferred = humanTracks.find(
    (t) => t.languageCode === preferredLanguage
  );
  if (humanPreferred) return humanPreferred;

  // Try any human caption
  if (humanTracks.length > 0) return humanTracks[0];

  // Try auto-generated in preferred language
  const autoPreferred = autoTracks.find(
    (t) => t.languageCode === preferredLanguage
  );
  if (autoPreferred) return autoPreferred;

  // Fall back to any auto-generated
  return autoTracks[0] || null;
}

/**
 * Check if captions are available for a video
 */
export function hasCaptions(): boolean {
  const playerResponse = extractPlayerResponse();
  if (!playerResponse) return false;

  const tracks = extractCaptionTracks(playerResponse);
  return tracks.length > 0;
}

/**
 * Get list of available caption tracks
 */
export function getAvailableTracks(): CaptionTrack[] {
  const playerResponse = extractPlayerResponse();
  if (!playerResponse) return [];

  return extractCaptionTracks(playerResponse);
}
