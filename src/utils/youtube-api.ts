import type {
  YouTubePlayerResponse,
  YouTubeCaptionTrack,
  CaptionTrack,
  TranscriptLine,
  YouTubeTimedText,
  Chapter,
} from '@/types';

/**
 * Extract video ID from YouTube URL
 */
export function extractVideoId(url: string): string | null {
  const patterns = [
    /[?&]v=([^&]+)/, // Standard watch URL
    /\/shorts\/([^/?]+)/, // Shorts URL
    /youtu\.be\/([^/?]+)/, // Short URL
    /\/embed\/([^/?]+)/, // Embed URL
  ];

  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match) {
      return match[1];
    }
  }

  return null;
}

/**
 * Extract ytInitialPlayerResponse from page
 * This contains caption track information
 */
export function extractPlayerResponse(): YouTubePlayerResponse | null {
  try {
    // Try to find ytInitialPlayerResponse in the page
    const scripts = document.querySelectorAll('script');
    for (const script of scripts) {
      const content = script.textContent || '';
      const match = content.match(/ytInitialPlayerResponse\s*=\s*({.+?});/);
      if (match) {
        return JSON.parse(match[1]) as YouTubePlayerResponse;
      }
    }

    // Fallback: try to get from window object
    const win = window as unknown as { ytInitialPlayerResponse?: YouTubePlayerResponse };
    if (win.ytInitialPlayerResponse) {
      return win.ytInitialPlayerResponse;
    }

    return null;
  } catch {
    console.error('[ClearTranscript] Failed to extract player response');
    return null;
  }
}

/**
 * Extract caption tracks from player response
 */
export function extractCaptionTracks(
  playerResponse: YouTubePlayerResponse
): CaptionTrack[] {
  const tracks =
    playerResponse.captions?.playerCaptionsTracklistRenderer?.captionTracks;

  if (!tracks || tracks.length === 0) {
    return [];
  }

  return tracks.map((track: YouTubeCaptionTrack) => ({
    languageCode: track.languageCode,
    languageName: track.name.simpleText,
    baseUrl: track.baseUrl,
    isAutoGenerated: track.kind === 'asr',
    isDefault: track.languageCode === 'en' || tracks.indexOf(track) === 0,
  }));
}

/**
 * Fetch transcript from YouTube timedtext endpoint
 */
export async function fetchTranscript(
  baseUrl: string
): Promise<TranscriptLine[]> {
  // Add format parameter for JSON3 format
  const url = new URL(baseUrl);
  url.searchParams.set('fmt', 'json3');

  const response = await fetch(url.toString());
  if (!response.ok) {
    throw new Error(`Failed to fetch transcript: ${response.status}`);
  }

  const data: YouTubeTimedText = await response.json();
  return parseTimedText(data);
}

/**
 * Parse YouTube timed text JSON into transcript lines
 */
function parseTimedText(data: YouTubeTimedText): TranscriptLine[] {
  if (!data.events) {
    return [];
  }

  return data.events
    .filter((event) => event.segs && event.segs.length > 0)
    .map((event) => ({
      start: event.tStartMs / 1000,
      duration: event.dDurationMs / 1000,
      text: event.segs!.map((seg) => seg.utf8).join('').trim(),
    }))
    .filter((line) => line.text.length > 0);
}

/**
 * Extract video description from page
 */
export function extractDescription(): string | null {
  try {
    // Try meta tag first
    const metaDesc = document.querySelector(
      'meta[name="description"]'
    ) as HTMLMetaElement;
    if (metaDesc?.content) {
      return metaDesc.content;
    }

    // Try to find in ytInitialData
    const scripts = document.querySelectorAll('script');
    for (const script of scripts) {
      const content = script.textContent || '';
      const match = content.match(/ytInitialData\s*=\s*({.+?});/);
      if (match) {
        const data = JSON.parse(match[1]);
        const description =
          data?.contents?.twoColumnWatchNextResults?.results?.results?.contents?.find(
            (c: Record<string, unknown>) => c.videoSecondaryInfoRenderer
          )?.videoSecondaryInfoRenderer?.attributedDescription?.content;
        if (description) {
          return description;
        }
      }
    }

    return null;
  } catch {
    return null;
  }
}

/**
 * Extract chapters from video
 */
export function extractChapters(): Chapter[] {
  try {
    const scripts = document.querySelectorAll('script');
    for (const script of scripts) {
      const content = script.textContent || '';
      const match = content.match(/ytInitialData\s*=\s*({.+?});/);
      if (match) {
        const data = JSON.parse(match[1]);
        const chapters =
          data?.playerOverlays?.playerOverlayRenderer?.decoratedPlayerBarRenderer
            ?.decoratedPlayerBarRenderer?.playerBar?.multiMarkersPlayerBarRenderer
            ?.markersMap?.[0]?.value?.chapters;

        if (chapters && Array.isArray(chapters)) {
          return chapters.map(
            (chapter: {
              chapterRenderer: {
                title: { simpleText: string };
                timeRangeStartMillis: number;
                thumbnail?: { thumbnails?: { url: string }[] };
              };
            }) => ({
              title: chapter.chapterRenderer.title.simpleText,
              start: chapter.chapterRenderer.timeRangeStartMillis / 1000,
              thumbnailUrl:
                chapter.chapterRenderer.thumbnail?.thumbnails?.[0]?.url,
            })
          );
        }
      }
    }

    return [];
  } catch {
    return [];
  }
}

/**
 * Get YouTube video player element
 */
export function getVideoPlayer(): HTMLVideoElement | null {
  return document.querySelector('video.html5-main-video');
}

/**
 * Get YouTube player container element
 */
export function getPlayerContainer(): HTMLElement | null {
  return document.querySelector('#movie_player');
}

/**
 * Check if video is in fullscreen mode
 */
export function isFullscreen(): boolean {
  return document.fullscreenElement !== null;
}

/**
 * Check if video is in theater mode
 */
export function isTheaterMode(): boolean {
  return document.querySelector('ytd-watch-flexy[theater]') !== null;
}

/**
 * Seek video to specific time
 */
export function seekTo(time: number): void {
  const video = getVideoPlayer();
  if (video) {
    video.currentTime = time;
  }
}

/**
 * Get current video time
 */
export function getCurrentTime(): number {
  const video = getVideoPlayer();
  return video?.currentTime ?? 0;
}

/**
 * Subscribe to video time updates
 */
export function onTimeUpdate(callback: (time: number) => void): () => void {
  const video = getVideoPlayer();
  if (!video) {
    return () => {};
  }

  const handler = () => callback(video.currentTime);
  video.addEventListener('timeupdate', handler);
  return () => video.removeEventListener('timeupdate', handler);
}
