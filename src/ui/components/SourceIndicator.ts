import type { TranscriptResult, CaptionTrack } from '@/types';
import { getSourceLabel } from '@/transcript/pipeline';

export interface SourceIndicatorProps {
  result: TranscriptResult;
  onLanguageChange?: (languageCode: string) => void;
}

/**
 * Create a source indicator component
 * Shows where the transcript came from and language options
 */
export function createSourceIndicator(props: SourceIndicatorProps): {
  element: HTMLElement;
  update: (result: TranscriptResult) => void;
} {
  const { result, onLanguageChange } = props;

  const container = document.createElement('div');
  container.className = 'ct-source-indicator';

  updateContent(container, result, onLanguageChange);

  return {
    element: container,
    update: (newResult: TranscriptResult) => {
      updateContent(container, newResult, onLanguageChange);
    },
  };
}

/**
 * Update source indicator content
 */
function updateContent(
  container: HTMLElement,
  result: TranscriptResult,
  onLanguageChange?: (languageCode: string) => void
): void {
  const label = getSourceLabel(result);
  const isPartial = result.tier === 'B' || (result.tier === 'C' && result.status !== 'complete');
  const hasLanguages = result.tier === 'A' && result.availableTracks.length > 1;

  container.innerHTML = `
    <div class="ct-source-badge ${getSourceClass(result)}">
      ${getSourceIcon(result)}
      <span>${label}</span>
      ${isPartial ? '<span class="ct-partial-badge">Partial</span>' : ''}
    </div>
    ${hasLanguages ? createLanguageSelector(result, onLanguageChange) : ''}
  `;

  // Attach language change handler if applicable
  if (hasLanguages && onLanguageChange) {
    const select = container.querySelector('.ct-language-select') as HTMLSelectElement;
    if (select) {
      select.addEventListener('change', () => {
        onLanguageChange(select.value);
      });
    }
  }
}

/**
 * Get CSS class for source type
 */
function getSourceClass(result: TranscriptResult): string {
  switch (result.source) {
    case 'youtube-captions':
      return 'ct-source-youtube';
    case 'youtube-auto-generated':
      return 'ct-source-auto';
    case 'fallback-partial':
      return 'ct-source-fallback';
    case 'server-transcription':
      return result.status === 'complete' ? 'ct-source-server' : 'ct-source-processing';
    default:
      return 'ct-source-fallback';
  }
}

/**
 * Get icon for source type
 */
function getSourceIcon(result: TranscriptResult): string {
  if (result.tier === 'C' && result.status === 'processing') {
    return `
      <svg class="ct-source-icon ct-spinning" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M12 2v4m0 12v4M4.93 4.93l2.83 2.83m8.48 8.48l2.83 2.83M2 12h4m12 0h4M4.93 19.07l2.83-2.83m8.48-8.48l2.83-2.83"/>
      </svg>
    `;
  }

  if (result.source === 'youtube-captions' || result.source === 'youtube-auto-generated') {
    return `
      <svg class="ct-source-icon" viewBox="0 0 24 24" fill="currentColor">
        <path d="M21.58 7.19c-.23-.86-.91-1.54-1.77-1.77C18.25 5 12 5 12 5s-6.25 0-7.81.42c-.86.23-1.54.91-1.77 1.77C2 8.75 2 12 2 12s0 3.25.42 4.81c.23.86.91 1.54 1.77 1.77C5.75 19 12 19 12 19s6.25 0 7.81-.42c.86-.23 1.54-.91 1.77-1.77C22 15.25 22 12 22 12s0-3.25-.42-4.81zM10 15V9l5.2 3-5.2 3z"/>
      </svg>
    `;
  }

  if (result.source === 'server-transcription') {
    return `
      <svg class="ct-source-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <rect x="2" y="3" width="20" height="14" rx="2"/>
        <path d="M8 21h8m-4-4v4"/>
      </svg>
    `;
  }

  return `
    <svg class="ct-source-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <circle cx="12" cy="12" r="10"/>
      <path d="M12 16v-4m0-4h.01"/>
    </svg>
  `;
}

/**
 * Create language selector HTML
 */
function createLanguageSelector(
  result: TranscriptResult,
  onLanguageChange?: (languageCode: string) => void
): string {
  if (result.tier !== 'A') return '';

  const options = result.availableTracks
    .map((track) => {
      const selected = track.languageCode === result.language ? 'selected' : '';
      const label = track.isAutoGenerated
        ? `${track.languageName} (auto)`
        : track.languageName;
      return `<option value="${track.languageCode}" ${selected}>${label}</option>`;
    })
    .join('');

  return `
    <select class="ct-language-select" title="Select language">
      ${options}
    </select>
  `;
}

/**
 * Get source indicator styles
 */
export function getSourceIndicatorStyles(): string {
  return `
    .ct-source-indicator {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 12px;
      background: var(--ct-bg-secondary);
      border-bottom: 1px solid var(--ct-border);
      font-size: 12px;
    }

    .ct-source-badge {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 4px;
      background: var(--ct-bg);
      color: var(--ct-text-secondary);
    }

    .ct-source-youtube {
      color: #ff0000;
    }

    .ct-source-auto {
      color: #909090;
    }

    .ct-source-server {
      color: #4caf50;
    }

    .ct-source-processing {
      color: #ff9800;
    }

    .ct-source-fallback {
      color: #9e9e9e;
    }

    .ct-source-icon {
      width: 14px;
      height: 14px;
    }

    .ct-spinning {
      animation: ct-spin 1s linear infinite;
    }

    @keyframes ct-spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    .ct-partial-badge {
      font-size: 10px;
      padding: 2px 4px;
      background: var(--ct-bg-secondary);
      border-radius: 2px;
      text-transform: uppercase;
    }

    .ct-language-select {
      background: var(--ct-bg);
      border: 1px solid var(--ct-border);
      border-radius: 4px;
      color: var(--ct-text);
      font-size: 12px;
      padding: 4px 8px;
      cursor: pointer;
      outline: none;
    }

    .ct-language-select:focus {
      border-color: var(--ct-accent);
    }
  `;
}
